

-------------
LeetCode #100
-------------



# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right




Recursive, pre-order DFS on binary trees. Same roots, same leaves, which are roots. If recursive, then several base cases.

class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        elif not p or not q:  # After the first condition failed, maximum one of these (p, q) are not true.
            return False
        elif p.val != q.val:  # After the second condition failed, the roots are not empty. So let's compare the values.
            return False
        
        # The recursive step:
        
        a = self.isSameTree(p.left, q.left)
        b = self.isSameTree(p.right, q.right)

        if a and b:
            return True
        else:
            return False
            
            
            
            
DFS - Depth-First Search. Recursive approach.

1. You use an implicit stack. What is popped are the recursive calls of the isSameTree function.
2. The approach 'inherits' True or False. E.g., one leaf has value of 1, and the analogous leaf of the second tree has the 
   value of 2. From p.val != q.val the False is returned, and saved in either a or b variable, thus this False will be
   inherited by the supra-iterations.
3. We are now bound to execute all the call stack... however, we already know that the trees are not identical, so this is
   inefficient. Therefore, we could use short-circuit evaluation or early return.
   
   
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if not p and not q:
            return True
        elif not p or not q or p.val != q.val:
            return False

        # The recursive step with short-circuiting:

        # We use logical 'and' operator. As soon as one of its operands is False, it stops the evaluation and returns False.
        # So if the left subtrees are not the same, it will not check the right subtrees.
        
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
        
        
        
        
However, both of these approaches are O(n) time and O(h) space (h could be n, in case of a skewed tree, or log(n) in case
of a balanced binary tree). n - the number of nodes.





-------------
LeetCode #104
-------------


Simple, recursive DFS:

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
        else:
            return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))




Iterative, pre-order DFS, with explicit stack emulating the call stack. Note that this pre-order traversal is not standard. We decide to traverse 
both children of a node (if they exist) before going deeper into the next level. In the above standard version, after processing the current node, 
we recursively traverse the left subtree, then we traverse the right subtree. This is what people generally mean when they refer to pre-order traversal.

class Solution:
    def maxDepth(self, root):
        
        max_depth = 0
        stack = [(root, 1)]
        
        while stack:
            node, depth = stack.pop()
            if node:
                max_depth = max(max_depth, depth)
                stack.append((node.left, depth + 1))
                stack.append((node.right, depth + 1))
        
        return max_depth






